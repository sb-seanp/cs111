Analysis of Solution

1. For the 2D bounce, the conceptual part was fairly easy. Every tick of the clock, the position needs to be updated. If the position is at a wall, just reverse the velocity of the wall it hit. Acceleration through gravity is applied via vf = vi + at in physics. The hard part was not getting the ball to sink through the floor. A hacky fix was made by making the y-position just the radius once the circle stopped bouncing. Damping was also done easily by multiplying the total force by the damping force.

2. Part 2 was harder. First off, I moved the individual variables into vectors to avoid having to write them out every single time like part 1, which only had 2 components and wasn't a huge deal. I originally tried to just copy the 2D version while adding z-components but then realised that the ball would go past the boundary and refuse to  bounce back at certain points. In fact, the mesh part of the ball would pass through the boundaries and obtain a blue highlight informing me it went past. 

I then figured out that the ball was going past the boundary because I didn't check the position of the ball before moving the ball and that the velocity changes were being applied even past the boundary. That solution may have worked in 2 dimensions but it did not work in 3 dimensions. I had to rethink my approach and check for collision BEFORE updating the position of the ball and then cheat by moving the ball before the boundary. So updated position but then did a check for collision before applying the updated position again if there was a collision. It is partially hacky because the position is being updated twice instead of checking ahead of time and I move the position back before a boundary but it was the only way I could get it to work.
